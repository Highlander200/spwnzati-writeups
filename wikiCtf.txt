Enciclopedia del catturamento della bandiera

Categorie:

	Misc:
		Forensics
		Steganography
		Scripting
			Linux
			Python
			Libraries
				Modules
	Network:
		Captures
		Dig
		
	Cypto:
		Encoding (kinda)
		Ciphers
		Encryptions
		Reversing (kinda)
		
	Web:
		Http
			Html
			Requests
			Cookie
		
		
	Software:
		Reverse
		Binary


Materiale:

	Slides Olicyber
	Video
	Stack Overflow
	Whatever


Challenge (maybe):
	
	Studio di un argomento ---> challenge di applicazione guidata ---> challenge avanzata
	

Documentazzo (Algoritmo (kinda) generale alla risoluzione del catturamento della bandiera):

	Esempio:
		Specifico:
			Cosa fare / passaggio_1 / passaggio_2 | opzione_a | opzione_b  --> tool** <--> esempio*
			
		tag qualcosa*:
			?? prova qualcos'altro

*se c'è quel tag prova questo			 
			 
** nome_tool
installazione tool
			
* spiegazione

	Misc:
		Forensics:
			Magic Bytes list--> https://en.wikipedia.org/wiki/List_of_file_signatures
				Modifica di Magic Bytes (NON FARLO DAL TEXT EDITOR*) --> https://hexed.it/
				
			Scan di file embeddati --> https://gchq.github.io/CyberChef/#recipe=Scan_for_Embedded_Files(true,true,true,true,true,true,false)
			
				Estrazione di file embeddati --> https://gchq.github.io/CyberChef/#recipe=Extract_Files(true,true,true,true,true,true,false,true,100)
							     --> zsteg** nome_file [vedere i parametri]
							         zsteg [parametri] nome_file 
** zsteg							         	
apt-get install -y ruby-dev
gem install rake
gem install zsteg
									
									
* il text editor non modifica fedelmente il contenuto del file ma può aggiungere altri byte per questo vanno usati tool appositi
			
		Steganograpy:
			TUTTO --> https://www.aperisolve.com/
			
		Scripting:
			usare os.system di python per runnare script <--> os.system("7z e " + " nome_file*")
			
	
	Network:
		Capture analisys --> wireshark**:
			Filtri --> filtrare per | protocollo <--> UDP | ip _whatever <--> 192.168.1.3  
			Cercare tra i pacchetti --> CTRL+F / cercare per | stringa | hex | regex / dentro a | packed details | packet bytes | packet list
			Analizzare flusso --> analyze / follow / flusso_da_analizzare stream <--> UDP stream
			Esportare oggetti --> file / export object / tipo_di_file_da_esportare <--> HTTP
			Controllare i commenti --> analyze / expert information / (se ci sono stanno in basso)
			
			?? key.log negli allegati --> decifrare il traffico TLS / edit / preference / protocols / cercare TLS / aggiungere il key.log
		
			tag remote:
				?? operazioni ripetibili <--> login falliti e login con successo / trovare il legame e sfruttarlo | "brute forcare" finchè non si propone la stessa situazione <--> Login = a e password = b / provo finchè non trovo il login a per usare la password b
			
				
	Crypto:
		Cipher:
			?? flag è in formato whatever{wathever_whatever_whatever} probabile cifrario a sostituzione da brute forcare (kinda) --> https://www.dcode.fr/
															    		     --> https://gchq.github.io/CyberChef/
															    		     --> https://quipqiup.com/
															    		     
				?? flag è in formato ABAB{BBAA_ABBBA_ABBBA} probabile bacon cipher --> https://gchq.github.io/CyberChef/#recipe=Bacon_Cipher_Decode('Standard%20(I%3DJ%20and%20U%3DV)','0/1',false)
			
			^ è XOR e si brute forca (KINDA) --> https://www.dcode.fr/chiffre-xor
						 	 --> https://gchq.github.io/CyberChef/#recipe=XOR_Brute_Force(1,100,0,'Standard',false,true,false,'')
			
		Decoding:
			?? stringa che finisce con == --> decode base 64 --> https://gchq.github.io/CyberChef/#recipe=From_Base64('A-Za-z0-9%2B/%3D',true,false)
			
		Decrypting:
		 
			?? c'è l'allegato con l'encrypter:
				reversalo (kinda) --> inizia dalla fine di ogni funzione / scrivine l'operazione contraria
			
			?? non c'è l'allegato:
				assumi che sia un HASH e analizzala --> https://gchq.github.io/CyberChef/#recipe=Analyse_hash()
				
			ENCRYPTION
				%n = p*q
				_n = (p-1)*(q-1)
				m = message
				e = dev'essere primo con m
				c = ciphertext = pow(m,e,%n)

			DECRYPTION	
				d = pow(e,-1,_n)

			LOGARITMO DISCRETO

				pow(a,b) % p
	
	Web:
		HTTP:
			analizzare il sito --> leggere il sorgente / controllare le richieste | cookie | URL | linguaggi e versioni usati (da sfruttare per vulnerabilità) <--> PHP
			analizzare il file /robots.txt --> potrebbe contenere pagine che il developer non vuole che conosciamo
			SQL injection --> (non so come si fanno, da completare i guess)
			
			?? invio di file --> controllare se questo viene eseguito dal server / nel caso lo faccia scrivere lo sript che pwni la flag :) (kinda)
			
			?? il sorgente --> analizzarlo per trovare vulnerabilità | modo con cui gestisce le richieste | cookie | invio di file | commenti
				   	
			js injection --> vedere sql injection
			
	Software:
		Binary:
			eseguire il file --> chmod +x nome_file / ./nome_file
			cercare di capire cosa fa il file
			usare --> ltrace, strace, strings, dll nome_file
			debuggare con gdb su qualche funzione sus--> gdb nome_file / break nome_funzione / run / info registers | wathever
			
		Reverse:
			pagina in costruzione (kinda)
			
		
			

** wireshark (su linux va installato via flatpak per avere l'ultima versione)

sudo apt install flatpak
sudo apt install gnome-software-plugin-flatpak
flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo

flatpak install flathub org.wireshark.Wireshark
				
			
